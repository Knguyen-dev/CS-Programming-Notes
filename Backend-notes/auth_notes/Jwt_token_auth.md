## Jwt Authentication
A form of token-based authentication based on an open standard (RFC 7519). Essentiallly a token is just a special string that the client will send to the server (through a request header). The server will look at this token, and check if its valid. If it's valid we can allow the user to get the resources they wanted, if not we can reject their request. This way the token ensures that the client has permission to make a request and access particular resources.

### Anatomy of a JWT Token:
A jwt token has a header, payload, and signature. All of them are separated by periods. So in the form of random letters "xxxx.yyyy.zzzz", where the first part is the header, second is the payload, and third is the signature.
1. Header: A base64 string that was created from the token's metadata. This metadata will contain the token's type (jwt in this case), and the algorithm used to create the jwt signature.
2. Payload: The base64 string generated from the data we wanted to embed into the jwt token, so in this case the user's data. 
3. Signature: String generated by hashing the header and payload with our secret.
- [A quick visualization](https://jwt.io/)

### How it works:
1. The user enters their username and password. The credentials are correct so the server creates a JWT.  To do this, we get some of the user's account information, such as their 'id' and 'role'; we want information that we can use to identify a user and verify if they have authority to do a specific task or get a resource. 
2. Then we choose a 'signing' algorithm, so let's use 'HMAC' algorithms, a group of algorithms that allow us to sign a message via a shared key. Basically we'll use a 'secret key', our messsage/data, and then a hash function (such as Sha256). Just know we'll use these 3 pieces of data later, and also the 'header' section of our jwt token contains the meta-data about the type of token and the algorithm encoding it.
3. Now we have our token meta data (token type and signing algorithm), our payload (user data), and then our 'secret'. Our 'secret' is a long string we will use for hashing that makes our jwt unique, and it's kept on the server. So first create a base64 string with the token metadata, that creates our header string of our jwt token. Then create a base64 string with the user's data to create the payload. Finally the server hashes the header and payload together with a secret. As a result, we are outputted a signature for our jwt, and so our signing of the jwt token is done! 
```
<!-- Function that outputs a signature for a particular jwt -->
function HMACSHA256(headerAndPayload, secret) {
    ...
}

function base64UrlEncode(data) {
    ...
}
const header = {
  "alg": "HS256",
  "typ": "JWT"
}
const payload = {
    id: 1,
    role: "user"
    <!--You can specify other things such as expiration time for the token -->
    "exp": 1592448654
}
const headerStr = base64UrlEncode(header)
const payloadStr = base64UrlEncode(payload)
const signature  = HMACSHA256(headerStr + '.' + payloadStr, secret)
const jwt = headerStr + "." + payload + "." + signature
```
4. The server sends this jwt to the client, in JSON format of course. Now let's say the user makes a request that requires permissions (e.g. changing their password). The user sends their request, their jwt token is in the header (in a header called 'Authorization') of their request. On our server we'll have middleware to check their jwt first, before letting the request go through. We take the header and payloads, both of them base64 encoded strings, and our secret (stored on our server), and we run it through our HMAC function again. As a result we get a jwt signature. If this computed jwt signature, matches the signature of the jwt token they gave us, that means it's valid. The signature in the JWT is generated using a combination of the header, payload, and a our personal secret key through a hashing algorithm (HMAC). This process ensures that any changes to the header or payload will result in a different signature. By recalculating the signature and comparing it to the one given by the client, we can confirm if it was a token generated by us. This guarantees the integrity of the data, meaning it has not been tampered with since it was issued. 
5. We'd then deserialize (decode) our jwt token, meaning we'll get the payload data for it. We'd get the id and role of the user. Then we can use this information to locate what user is making the request to have a password change. And of course for some other endpoint, you may make use of role to ensure whether or not the user has permission to access or do something.

### Security
It's important to keep the secret key hidden, because if someone used our secret, they could create jwt signatures that matches us. As a result, we wouldn't know whether or not a jwt has been signed by us, or by someone else using the same key as us.

### Benefits and when to use jwt
- Stateless: All information needed to do a request is in the jwt. With sessions, you'd have to check the database t osee if a session is still valid (if user still authenticated), but with a jwt all info is self-contained so you just need to check the jwt. Typically no database is involved. 
- Portable: If two servers have the same secret key, then you can easily have the case where if they sign in on one server, they're authenticated for all others. In applications that are driven via APIs and microservices you could use the JWT to authenticate the client with those various microservices.

### JWT Credits:
1. [Web Dev Simplified](https://www.youtube.com/watch?v=7Q17ubqLfaM)
2. [Jwt visualized chart](https://roadmap.sh/guides/jwt-authentication.png)
3. [Intro to JWT](https://jwt.io/introduction)

## Token-Based Authentication
A token-based authentication where users verify their identity, and in return they receive a 'access token'. This access token is valid for a short duration, and during this, the user is treated as authenticated and doesn't have to re-enter their credentials in that timeframe to re-authenticate.

### How it works:
1. User makes a request for resources, could involve credentials.
2. Verify the credentials, so like checking the username and password for example.
3. It's good, so server gives the user a token. The token is then stored somewhere, usually in the user's browser.

### Access tokens
When the user logs in, our server gives them an access token. This token is used by the client prove to the server that they are authorized to access protected server resources. It lets the server determine if the client has the 'authorization to access' certain resources. However once it expires, the client app could ask the user to login again to get a new access token. Or the alternative would be giving the client a refresh token to replace their expired token with.

- NOTE: However, access tokens can of course we stolen. With access tokens we can only determine whether or not it's valid, not who 'owns' it. So a malicious user can take a valid access token, and attempt to make requests, on the behalf of the user who was originally given that access token. One of the solutions for this, is to make access tokens have a very short lifespan, making it so that even if a malicious actor has an access token, there would be a very short time-frame for it to be valid.

### Refresh tokens
An access token with a short life span is good security. Then when it expires, the client app can use a long-lived refresh token to give the user a new access token. 

1. User logs in, the authorization server gives the client app an access token and refresh token.
2. The client app sends the access token over the network to the server when making API requests. Then the server sends back that the protected resource.
3. When our access token expires, we send the refresh token to the auth server, and then the auth server sends us back a new access token.
- NOTE: Refresh tokens can be a little more secure since they're also stored on the client, and aren't sent over with every api request like access tokens. But of course there's a chance refresh tokens can be intercepted. Refresh tokens are also bearer tokens so we need ways to secure this.

### Best practices for authentication tokens
- Privacy: Users can't share token authentication devices or pass them around. Like how they shouldn't share passwords.
- Secure: Client and server should have secure HTTPS connections.
- Appropriate: The right token should be picked for the right use case.

### 3 Authentication Token Types 
Here are 3 common types of authentication tokens:
- Connected: Keys, discs, drives, and other physical items we plug into the system to get access and login.
- Contactless: A device is close enough to the server to wirelessly communicate with it.
- Disconeccted: A device can communicate with the server across long distances. Such as using your phone for 2FA.

### Credits: 
1. [What is token-based authentication](https://www.okta.com/identity-101/what-is-token-based-authentication/)
2. [Access and Refresh tokens](https://www.youtube.com/watch?v=-Z57Ss_uiuc)
3. [More on access and refresh tokens](https://www.youtube.com/watch?v=LowJMwa7LCU)
